//******************************************************************************
//******************************************************************************
//
//  Hardware component interfaces
//
//
//  Description: This header defines interfaces for hardware components like
//							 detectors, projectors, linear stages, rotary stages, robots, etc.
//
//******************************************************************************
//******************************************************************************
#ifndef mmIHardwareH
#define mmIHardwareH

#include <mmGlobalDefs.h>
#include <mmError.h>
#include <math\mmMath.h>
#include <interfaces\mmGlobalInterfacesStorage.h>
#include <windows.h>

namespace mmImageProcessing
{
	////////////////////////////////////////////////////////////////////////////////
	/// Enumeration for definition of pixel color packing.
	////////////////////////////////////////////////////////////////////////////////
	typedef enum
	{
		////////////////////////////////////////////////////////////////////////////////
		/// Pixel is represented by by 3 bytes Red, Green and Blue.
		////////////////////////////////////////////////////////////////////////////////
		pixel_R8G8B8		=	0x00000000,
		////////////////////////////////////////////////////////////////////////////////
		/// Pixel is represented by by 3 bytes Blue, Green and Red.
		////////////////////////////////////////////////////////////////////////////////
		pixel_B8G8R8 		= 0x00000001,
		////////////////////////////////////////////////////////////////////////////////
		/// Pixel is represented by one grayscale intensity byte value.
		////////////////////////////////////////////////////////////////////////////////
		pixel_Gray8			= 0x00000002,
		////////////////////////////////////////////////////////////////////////////////
		/// Pixel is represented by 16bit grayscale intensity value.
		////////////////////////////////////////////////////////////////////////////////
		pixel_Gray16		= 0x00000003,
		////////////////////////////////////////////////////////////////////////////////
		/// Pixel is represented by 3 16bit values Red, Green and Blue. (Deep color)
		////////////////////////////////////////////////////////////////////////////////
		pixel_R16G16B16	= 0x00000004,
		////////////////////////////////////////////////////////////////////////////////
		/// Pixel is represented by by 4 bytes Red, Green, Blue and Alpha
		////////////////////////////////////////////////////////////////////////////////
		pixel_R8G8B8A8	=	0x00000005,
		////////////////////////////////////////////////////////////////////////////////
		/// Pixel is represented by by 4 bytes Blue, Green, Red and Alpha
		////////////////////////////////////////////////////////////////////////////////
		pixel_B8G8R8A8	= 0x00000006,
		////////////////////////////////////////////////////////////////////////////////
		/// Pixel format irrelevant, doesn't matter or undefined
		////////////////////////////////////////////////////////////////////////////////
		pixel_AnyType		=	-1
		////////////////////////////////////////////////////////////////////////////////
	} ePixelType;

	mmInt GetPixelSize(mmImageProcessing::ePixelType p_ePixelType);
}

////////////////////////////////////////////////////////////////////////////////
/// This namespace defines functionality of basic hardware components
/// like detector, projector, linear and rotary stages, robot, etc.
////////////////////////////////////////////////////////////////////////////////
namespace mmHardware
{
	////////////////////////////////////////////////////////////////////////////////
	/// Structure defines raw image data packing for hardware operations.
	////////////////////////////////////////////////////////////////////////////////

	// //////////////////// ???????

		typedef struct
	{
		////////////////////////////////////////////////////////////////////////////////
		/// Image width.
		////////////////////////////////////////////////////////////////////////////////
		mmInt iWidth;
		////////////////////////////////////////////////////////////////////////////////
		/// Image height.
		////////////////////////////////////////////////////////////////////////////////
		mmInt iHeight;
		////////////////////////////////////////////////////////////////////////////////
		/// Pixel packing.
		////////////////////////////////////////////////////////////////////////////////
		mmImageProcessing::ePixelType ePixType;
	} sImageDef;

	////////////////////////////////////////////////////////////////////////////////
	/// Mechanical manipulator interface.
	////////////////////////////////////////////////////////////////////////////////
	class mmManipulatorI
	{
		public:
			////////////////////////////////////////////////////////////////////////////////
			/// Definition of manipulator status enum.
			////////////////////////////////////////////////////////////////////////////////
			enum mmManipulatorStatus
			{
				////////////////////////////////////////////////////////////////////////////////
				/// Manipulator axis is stopped.
				////////////////////////////////////////////////////////////////////////////////
				mmmsStopped		= 0,
                ////////////////////////////////////////////////////////////////////////////////
				/// Manipulator axis is moving.
				////////////////////////////////////////////////////////////////////////////////
				mmmsMoving		= 1,
                ////////////////////////////////////////////////////////////////////////////////
				/// Manipulator axis is blocked.
				////////////////////////////////////////////////////////////////////////////////
				mmmsBlocked		= 2,
                ////////////////////////////////////////////////////////////////////////////////
				/// Manipulator axis is disconnected.
				////////////////////////////////////////////////////////////////////////////////
				mmmsDisconected	= 3,
				////////////////////////////////////////////////////////////////////////////////
				/// Manipulator axis status is unknown.
				////////////////////////////////////////////////////////////////////////////////
				mmmsUnknown		= 4

			};

			////////////////////////////////////////////////////////////////////////////////
			/// Virtual destructor.
			////////////////////////////////////////////////////////////////////////////////
			virtual ~mmManipulatorI(void) {};

			////////////////////////////////////////////////////////////////////////////////
			/// Method initializes manipulator. LoadManipulatorGlobalParameters() or
			/// SetManipulatorGlobalParameters() has to be done before calling
			/// InitializeManipulator().If manipulator is not initialized, it can't moved.
			///
			/// @return TRUE if no error occured, FALSE otherwise.
			////////////////////////////////////////////////////////////////////////////////
			virtual BOOL InitializeManipulator(void) = 0;

			////////////////////////////////////////////////////////////////////////////////
			/// Method synchronizes manipulator driver. Synchronization is automatically
			/// done in InitializeManipulator() method.
			///
			/// @param[in] p_uiRepeatCount how many times method tries to synchronize driver,
			/// @return TRUE if no error occured, FALSE otherwise.
			////////////////////////////////////////////////////////////////////////////////
			virtual BOOL Synchronize(unsigned int p_uiRepeatCount = 40) {return FALSE;};

			////////////////////////////////////////////////////////////////////////////////
			/// Method returns XML structure with manipulator axis parameters.
			///
			/// @param[in] p_uiAxisNumber number of manipulator axis,
			/// @return XML structure with manipulator axis parameters.
			////////////////////////////////////////////////////////////////////////////////
			virtual mmString GetManipulatorParameters(unsigned int p_uiAxisNumber = 1) {return NULL;};

			////////////////////////////////////////////////////////////////////////////////
			/// Method sets manipulator axis parameters.
			///
			/// @param[in] p_sAxisParameters XML structure withm anipulator axis parameters,
			/// @return TRUE if no error occured, FALSE otherwise.
			////////////////////////////////////////////////////////////////////////////////
			virtual BOOL SetManipulatorParameters(mmString p_sAxisParameters,
													unsigned int p_uiAxisNumber = 1) {return FALSE;};

			////////////////////////////////////////////////////////////////////////////////
			/// Method loads manipulator parameters from XML file.
			///
			/// @param[in] p_sFilePath path to file with manipulator parameters XML structure,
			/// @return TRUE if no error occured, FALSE otherwise.
			////////////////////////////////////////////////////////////////////////////////
			virtual BOOL LoadManipulatorGlobalParameters(mmString p_sFilePath) = 0;

            ////////////////////////////////////////////////////////////////////////////////
			/// Method returns XML structure with manipulator parameters.
			///
			/// @return XML structure with manipulator axis parameters.
			////////////////////////////////////////////////////////////////////////////////
			virtual mmString GetManipulatorGlobalParameters(void) {return NULL;};

			////////////////////////////////////////////////////////////////////////////////
			/// Method sets manipulator parameters.
			///
			/// @param[in] p_sManipulatorGlobalParameters XML structure with manipulator parameters,
			/// @return TRUE if no error occured, FALSE otherwise.
			////////////////////////////////////////////////////////////////////////////////
			virtual BOOL SetManipulatorGlobalParameters(mmString p_sManipulatorGlobalParameters) {return FALSE;};

			////////////////////////////////////////////////////////////////////////////////
			/// Method saves XML structure with manipulator parameters to file.
			///
			/// @param[in] p_sFilePath path to file,
			/// @return TRUE if no error occured, FALSE otherwise.
			////////////////////////////////////////////////////////////////////////////////
			virtual BOOL SaveManipulatorGlobalParameters(mmString p_sFilePath) {return FALSE;};

			////////////////////////////////////////////////////////////////////////////////
			/// Method loads manipulator state from XML file.
			///
			/// @param[in] p_sFilePath path to file with manipulator state XML structure,
			/// @return TRUE if no error occured, FALSE otherwise.
			////////////////////////////////////////////////////////////////////////////////
			virtual BOOL LoadManipulatorGlobalState(mmString p_sFilePath) {return FALSE;};

			////////////////////////////////////////////////////////////////////////////////
			/// Method saves XML structure with manipulator state to file.
			///
			/// @param[in] p_sFilePath path to file,
			/// @return TRUE if no error occured, FALSE otherwise.
			////////////////////////////////////////////////////////////////////////////////
			virtual BOOL SaveManipulatorGlobalState(mmString p_sFilePath) {return FALSE;};

			////////////////////////////////////////////////////////////////////////////////
			/// Method returns number of manipulator axes.
			///
			/// @return number of manipulator axes.
			////////////////////////////////////////////////////////////////////////////////
			virtual unsigned int GetManipulatorAxisCount(void) {return 0;};

			////////////////////////////////////////////////////////////////////////////////
			/// Method returns working mode of an axis of manipulator. Active means that it
			/// can be manipulated. Passive that it can only return actual transformations,
			/// all movements are performed out of control of application.
			///
			/// @param[in] p_uiAxisNumber axis number,
			/// @return TRUE if it can't be controllable, FALSE otherwise.
			////////////////////////////////////////////////////////////////////////////////
			virtual BOOL IsPassive(unsigned int p_uiAxisNumber = 1) {return TRUE;};

			////////////////////////////////////////////////////////////////////////////////
			/// Method returns status of manipulator axis.
			///
			/// @param[in] p_uiAxisNumber axis number,
			/// @return status of manipulator axis.
			////////////////////////////////////////////////////////////////////////////////
			virtual mmManipulatorStatus GetManipulatorStatus(unsigned int p_uiAxisNumber = 1) {return mmmsUnknown;};

			////////////////////////////////////////////////////////////////////////////////
			/// Method returns position of manipulator axis.
			///
			/// @param[in] p_uiAxisNumber axis number,
			/// @return position of manipulator axis.
			////////////////////////////////////////////////////////////////////////////////
			virtual mmReal GetPosition(unsigned int p_uiAxisNumber = 1) {return 0.0;};

			////////////////////////////////////////////////////////////////////////////////
			/// Method realizes manipulation of manipulator axis.
			///
			/// @param[in] p_rValue manipulation value in units appropriate for axis type,
			/// @param[in] p_uiAxisNumber axis number,
			/// @return real manipulation value.
			////////////////////////////////////////////////////////////////////////////////
			virtual mmReal Move(mmReal p_rValue, unsigned int p_uiAxisNumber = 1) = 0;

			////////////////////////////////////////////////////////////////////////////////
			/// Method realizes emergency stop of all axes of manipulator.
			////////////////////////////////////////////////////////////////////////////////
			virtual void EmergencyStop(void) = 0;

			////////////////////////////////////////////////////////////////////////////////
			/// Method realizes user action.
			///
			/// @param[in] p_sUserAction XML structure with user action command,
			/// @return XML structure with manipulator reply.
			////////////////////////////////////////////////////////////////////////////////
			virtual mmString UserAction(mmString p_sUserAction) {return NULL;};
	};

	////////////////////////////////////////////////////////////////////////////////
	/// Manipulator container interface. It is responsible for
	/// searching all available manipulators and querying them. It also initializes
	/// manipulator objects and return pointers to them.
	////////////////////////////////////////////////////////////////////////////////
	class mmManipulatorContainerI
	{
		public:			// name
			////////////////////////////////////////////////////////////////////////////////
			/// Virtual destructor.
			////////////////////////////////////////////////////////////////////////////////
			virtual ~mmManipulatorContainerI() {};

			////////////////////////////////////////////////////////////////////////////////
			/// Returns list with names of available manipulators.
			///
			/// @return vector with names defining available manipulators.
			////////////////////////////////////////////////////////////////////////////////
			virtual std::vector<mmString> GetAvailableManipulators(void) = 0;

			////////////////////////////////////////////////////////////////////////////////
			/// Initializes selected manipulator and returns pointer into its interface.
			/// In case of error it throws  mmError(mmeHardwareUnknownManipulator).
			///
			/// @param[in] p_sManipulatorName name of manipulator to initialize,
			/// @return pointer to initialized mmHardware::mmManipulatorI object.
			////////////////////////////////////////////////////////////////////////////////
			virtual mmHardware::mmManipulatorI* InitializeManipulator(mmString p_sManipulatorName) = 0;
	};


	////////////////////////////////////////////////////////////////////////////////
	/// Detector interface.
	////////////////////////////////////////////////////////////////////////////////
	class mmDetectorI
	{
		private:		// fields
			////////////////////////////////////////////////////////////////////////////////
			/// ID name of detector.
			////////////////////////////////////////////////////////////////////////////////
			mmString m_sName;
		protected:  // methods
			////////////////////////////////////////////////////////////////////////////////
			/// Method sets name of detector.
			///
			/// @param[in] p_sName detector name
			////////////////////////////////////////////////////////////////////////////////
			void SetName(mmString p_sName)
			{
				m_sName = p_sName;
			};
		public:			// methods
			////////////////////////////////////////////////////////////////////////////////
			/// Virtual destructor.
			////////////////////////////////////////////////////////////////////////////////
			virtual ~mmDetectorI() {};

			////////////////////////////////////////////////////////////////////////////////
			/// Method returns name of detector.
			///
			/// @return name of detector
			////////////////////////////////////////////////////////////////////////////////
			const wchar_t* GetName(void)
			{
				return m_sName.c_str();
			};

			////////////////////////////////////////////////////////////////////////////////
			/// Method returns XML structure with global params of detector. These params
			/// are used globally, they are not changing from image to image.
			///
			/// @return XML structure with global parameters
			////////////////////////////////////////////////////////////////////////////////
			virtual mmString GetXMLGlobalParams(void) = 0;

			////////////////////////////////////////////////////////////////////////////////
			/// Method returns XML structure with global params of detector. These params
			/// are used globally, they are not changing from image to image.
			///
			/// @param[in] p_pcXMLParamsBuffer buffer with XML structure with global parameters
			/// @param[in] p_iXMLParamsBufferSize size of buffer
			////////////////////////////////////////////////////////////////////////////////
			virtual void GetXMLGlobalParams(	wchar_t* p_pcXMLParamsBuffer,
												mmInt p_iXMLParamsBufferSize) = 0;

			////////////////////////////////////////////////////////////////////////////////
			/// Method sets new set of global params for detector. In case of error
			/// it throws mmError(mmeHardwareBadInputParams) and
			/// mmError(mmeHardwareBadRangeForParamsValue).
			///
			///	@param[in] p_sXMLParams XML definition of global detector parameters.
			////////////////////////////////////////////////////////////////////////////////
			virtual void SetXMLGlobalParams(mmString p_sXMLParams) = 0;

			////////////////////////////////////////////////////////////////////////////////
			/// Method sets new set of global params for detector. In case of error
			/// it throws mmError(mmeHardwareBadInputParams) and
			/// mmError(mmeHardwareBadRangeForParamsValue).
			///
			///	@param[in] p_pcXMLParams XML definition of global detector parameters.
			////////////////////////////////////////////////////////////////////////////////
			virtual void SetXMLGlobalParams(wchar_t* p_pcXMLParams) = 0;

			////////////////////////////////////////////////////////////////////////////////
			/// Method returns XML structure with image parameters. These parameters can be
			/// changed from image to image.
			///
			/// @return XML structure with image parameters
			////////////////////////////////////////////////////////////////////////////////
			virtual mmString GetXMLImageParams(void) = 0;

			////////////////////////////////////////////////////////////////////////////////
			/// Method returns XML structure with image parameters. These parameters can be
			/// changed from image to image.
			///
			/// @param[in] p_pcXMLParamsBuffer buffer with XML structure with image parameters
			/// @param[in] p_iXMLParamsBufferSize size of buffer
			////////////////////////////////////////////////////////////////////////////////
			virtual void GetXMLImageParams(	wchar_t* p_pcXMLParamsBuffer,
											mmInt p_iXMLParamsBufferSize) = 0;

			////////////////////////////////////////////////////////////////////////////////
			/// Method sets new set of local params for detector. In case of error
			/// it throws mmError(mmeHardwareBadInputParams) and
			/// mmError(mmeHardwareBadRangeForParamsValue).
			///
			///	@param[in] p_sXMLParams XML definition of local detector parameters.
			////////////////////////////////////////////////////////////////////////////////
			virtual void SetXMLImageParams(mmString p_sXMLParams) = 0;

			////////////////////////////////////////////////////////////////////////////////
			/// Method sets new set of local params for detector. In case of error
			/// it throws mmError(mmeHardwareBadInputParams) and
			/// mmError(mmeHardwareBadRangeForParamsValue).
			///
			///	@param[in] p_pcXMLParams XML definition of local detector parameters.
			////////////////////////////////////////////////////////////////////////////////
			virtual void SetXMLImageParams(wchar_t* p_pcXMLParams) = 0;

			////////////////////////////////////////////////////////////////////////////////
			/// Method captures image from detector. In case of error it throws
			/// mmError(mmeHardwareCantCapture).
			////////////////////////////////////////////////////////////////////////////////
			virtual void CaptureImage(void) = 0;

			////////////////////////////////////////////////////////////////////////////////
			/// Method returns captured image count.
			///
			/// @return count of captured image.
			////////////////////////////////////////////////////////////////////////////////
			virtual mmInt GetCapturedImagesCount(void) = 0;

			////////////////////////////////////////////////////////////////////////////////
			/// Method returns info about previously captured image. In case of error
			/// it throws	mmError(mmeHardwareImageOutOfRange).
			///
			/// @param[in] p_iImageIndex index of requested image
			/// @return information about image
			////////////////////////////////////////////////////////////////////////////////
			virtual sImageDef GetImageInfo(mmInt p_iImageIndex) = 0;

			////////////////////////////////////////////////////////////////////////////////
			/// Method returns previously captured image. In case of error it throws
			///	mmError(mmeHardwareImageOutOfRange).
			///
			/// @param[in] p_iImageIndex index of requested image
			/// @param[in] p_psImageData pointer where image data have to be copied.
			////////////////////////////////////////////////////////////////////////////////
			virtual void GetImageData(	mmInt p_iImageIndex,
										void* p_psImageData) = 0;

			////////////////////////////////////////////////////////////////////////////////
			/// Method deletes all images stored in detector memory.
			////////////////////////////////////////////////////////////////////////////////
			virtual void DeleteAllImages(void) = 0;

			////////////////////////////////////////////////////////////////////////////////
			/// Method returns info about flash state.
			///
			/// @return TRUE if flash function is enabled, FALSE otherwise.
			////////////////////////////////////////////////////////////////////////////////
			virtual bool IsFlashOn(void) = 0;

			////////////////////////////////////////////////////////////////////////////////
			/// Method sets flash state.
			///
			/// @param[in] p_bFlashOnOff new flash state
			////////////////////////////////////////////////////////////////////////////////
			virtual void SetFlash(bool p_bFlashOnOff) = 0;

			////////////////////////////////////////////////////////////////////////////////
			/// Method saves detector state into XML file. It not save images.
			///
			/// @param[in] p_sPathToFile path to XML file.
			////////////////////////////////////////////////////////////////////////////////
			virtual void SaveStateInXMLFile(mmString p_sPathToFile) = 0;

			////////////////////////////////////////////////////////////////////////////////
			/// Method saves detector state into XML file. It not save images.
			///
			/// @param[in] p_pcPathToFile path to XML file.
			////////////////////////////////////////////////////////////////////////////////
			virtual void SaveStateInXMLFile(wchar_t* p_pcPathToFile) = 0;

			////////////////////////////////////////////////////////////////////////////////
			/// Method loads detector state from XML file.
			///
			/// @param[in] p_sPathToFile path to XML file.
			////////////////////////////////////////////////////////////////////////////////
			virtual void LoadStateFromXMLFile(mmString p_sPathToFile) = 0;

			////////////////////////////////////////////////////////////////////////////////
			/// Method loads detector state from XML file.
			///
			/// @param[in] p_pcPathToFile path to XML file.
			////////////////////////////////////////////////////////////////////////////////
			virtual void LoadStateFromXMLFile(wchar_t* p_pcPathToFile) = 0;
	};

	////////////////////////////////////////////////////////////////////////////////
	/// Detector container interface. It is responsible for
	/// searching all available detectors and querying them. It also initializes
	/// detector objects and return pointers to them.
	////////////////////////////////////////////////////////////////////////////////
	class mmDetectorContainerI
	{
		public:			// name
    		////////////////////////////////////////////////////////////////////////////////
			/// Virtual destructor.
			////////////////////////////////////////////////////////////////////////////////
			virtual ~mmDetectorContainerI() {};

			////////////////////////////////////////////////////////////////////////////////
			/// Returns list with names of available detectors.
			///
			/// @return vector with names defining available detectors.
			////////////////////////////////////////////////////////////////////////////////
			virtual std::vector<mmString> GetAvailableDetectors(void) = 0;

			////////////////////////////////////////////////////////////////////////////////
			/// Initializes selected detector and returns pointer into its interface.
			/// In case of error it throws mmError(mmeHardwareUnknownDetector).
			///
			/// @param[in] p_sDetectorName name of detector to initialize,
			/// @return pointer to initialized mmHardware::mmDetectorI object.
			////////////////////////////////////////////////////////////////////////////////
			virtual mmHardware::mmDetectorI* InitializeDetector(mmString p_sDetectorName) = 0;
	};



	////////////////////////////////////////////////////////////////////////////////
	/// Projector interface.
	////////////////////////////////////////////////////////////////////////////////
	class mmProjectorI
	{
		public:			// definitions
			////////////////////////////////////////////////////////////////////////////////
			/// Definition of projected image type.
			////////////////////////////////////////////////////////////////////////////////
			typedef enum
			{
				////////////////////////////////////////////////////////////////////////////////
				/// Image with constant intensity (image is defined by one pixel value).
				////////////////////////////////////////////////////////////////////////////////
				constant_intensity										= 0,
				////////////////////////////////////////////////////////////////////////////////
				/// Image with horizontal orientation (image is defined by one row).
				////////////////////////////////////////////////////////////////////////////////
				horizontal_orientation								=	1,
				////////////////////////////////////////////////////////////////////////////////
				/// Image with vertical orientation (image is defined by one column).
				////////////////////////////////////////////////////////////////////////////////
				vertical_orientation									= 2,
				////////////////////////////////////////////////////////////////////////////////
				/// Image with horizontal orientation (image is defined by one row).
				////////////////////////////////////////////////////////////////////////////////
				horizontal_and_vertical_orientation		=	3,
				////////////////////////////////////////////////////////////////////////////////
				/// Two-dimensional image (each pixel of image is defined).
				////////////////////////////////////////////////////////////////////////////////
				image2D																= 4
			} eProjectorImageType;
			////////////////////////////////////////////////////////////////////////////////
			/// Definition of projector image.
			////////////////////////////////////////////////////////////////////////////////
			typedef struct
			{
				////////////////////////////////////////////////////////////////////////////////
				/// Image type.
				////////////////////////////////////////////////////////////////////////////////
				eProjectorImageType eImageType;
				////////////////////////////////////////////////////////////////////////////////
				/// Red intensities.
				////////////////////////////////////////////////////////////////////////////////
				std::vector<unsigned char> vRed;
				////////////////////////////////////////////////////////////////////////////////
				/// Green intensities.
				////////////////////////////////////////////////////////////////////////////////
				std::vector<unsigned char> vGreen;
				////////////////////////////////////////////////////////////////////////////////
				/// Blue intensities.
				////////////////////////////////////////////////////////////////////////////////
				std::vector<unsigned char> vBlue;
				////////////////////////////////////////////////////////////////////////////////
				/// Defines if quality of measurement will increase if this image will be
				/// reperated and further averaged.
				////////////////////////////////////////////////////////////////////////////////
				bool bIsRepeatable;
			} sProjectorImageDef;
		private:		// fields
			////////////////////////////////////////////////////////////////////////////////
			/// ID name of projector.
			////////////////////////////////////////////////////////////////////////////////
			mmString m_sName;
		protected:  // methods
			////////////////////////////////////////////////////////////////////////////////
			/// Method sets name of projector.
			///
			/// @param[in] p_sName projector name
			////////////////////////////////////////////////////////////////////////////////
			void SetName(mmString p_sName)
			{
				m_sName = p_sName;
			};
		public:			// methods
			////////////////////////////////////////////////////////////////////////////////
			/// Virtual destructor.
			////////////////////////////////////////////////////////////////////////////////
			virtual ~mmProjectorI() {};

			////////////////////////////////////////////////////////////////////////////////
			/// Method returns name of projector.
			///
			/// @return name of projector
			////////////////////////////////////////////////////////////////////////////////
			const wchar_t* GetName(void)
			{
				return m_sName.c_str();
			};

			////////////////////////////////////////////////////////////////////////////////
			/// Method returns XML structure with global params of projector. These params
			/// are used globally, they are not changing from image to image projected.
			///
			/// @return XML structure with global parameters
			////////////////////////////////////////////////////////////////////////////////
			virtual mmString GetXMLGlobalParams(void) = 0;

			////////////////////////////////////////////////////////////////////////////////
			/// Method returns XML structure with global params of projector. These params
			/// are used globally, they are not changing from image to image projected.
			///
			/// @param[in] p_pcXMLParamsBuffer buffer with XML structure with global parameters
			/// @param[in] p_iXMLParamsBufferSize size of buffer
			////////////////////////////////////////////////////////////////////////////////
			virtual void GetXMLGlobalParams(wchar_t* p_pcXMLParamsBuffer,
																			mmInt p_iXMLParamsBufferSize) = 0;

			////////////////////////////////////////////////////////////////////////////////
			/// Method sets new set of global params for projector. In case of error
			/// it throws mmError(mmeHardwareBadInputParams) and
			/// mmError(mmeHardwareBadRangeForParamsValue).
			///
			///	@param[in] p_sXMLParams XML definition of global projector parameters.
			////////////////////////////////////////////////////////////////////////////////
			virtual void SetXMLGlobalParams(mmString p_sXMLParams) = 0;

			////////////////////////////////////////////////////////////////////////////////
			/// Method sets new set of global params for projector. In case of error
			/// it throws mmError(mmeHardwareBadInputParams) and
			/// mmError(mmeHardwareBadRangeForParamsValue).
			///
			///	@param[in] p_pcXMLParams XML definition of global projector parameters.
			////////////////////////////////////////////////////////////////////////////////
			virtual void SetXMLGlobalParams(wchar_t* p_pcXMLParams) = 0;

			////////////////////////////////////////////////////////////////////////////////
			/// Method returns XML structure with projected image parameters. These
			/// parameters can be changed from image to image projected.
			///
			/// @return XML structure with projected image parameters
			////////////////////////////////////////////////////////////////////////////////
			virtual mmString GetXMLImageParams(void) = 0;

			////////////////////////////////////////////////////////////////////////////////
			/// Method returns XML structure with projected image parameters. These
			/// parameters can be changed from image to image projected.
			///
			/// @param[in] p_pcXMLParamsBuffer buffer with XML structure with image parameters
			/// @param[in] p_iXMLParamsBufferSize size of buffer
			////////////////////////////////////////////////////////////////////////////////
			virtual void GetXMLImageParams(wchar_t* p_pcXMLParamsBuffer,
																		 mmInt p_iXMLParamsBufferSize) = 0;

			////////////////////////////////////////////////////////////////////////////////
			/// Method sets new values of projected image. In case of error
			/// it throws mmError(mmeHardwareBadInputParams) and
			/// mmError(mmeHardwareBadRangeForParamsValue).
			///
			///	@param[in] p_sXMLParams XML definition of local projector parameters.
			////////////////////////////////////////////////////////////////////////////////
			virtual void SetXMLImageParams(mmString p_sXMLParams) = 0;

			////////////////////////////////////////////////////////////////////////////////
			/// Method sets new values of projected image. In case of error
			/// it throws mmError(mmeHardwareBadInputParams) and
			/// mmError(mmeHardwareBadRangeForParamsValue).
			///
			///	@param[in] p_pcXMLParams XML definition of local projector parameters.
			////////////////////////////////////////////////////////////////////////////////
			virtual void SetXMLImageParams(wchar_t* p_pcXMLParams) = 0;

			////////////////////////////////////////////////////////////////////////////////
			/// This method initialises image sequence to project.
			///
			/// @param[in] p_psProjImages pointer to vector storing image sequence definition
			////////////////////////////////////////////////////////////////////////////////
			virtual void InitializeImageSequence(std::vector<mmHardware::mmProjectorI::sProjectorImageDef>* p_psProjImages) = 0;

			////////////////////////////////////////////////////////////////////////////////
			/// This method returns count of initialized image sequence.
			///
			/// @return count of initialized image sequence
			////////////////////////////////////////////////////////////////////////////////
			virtual mmInt GetInitializedImageSequenceCount(void) = 0;

			////////////////////////////////////////////////////////////////////////////////
			/// Method starts rendering process. In case of error
			/// it throws mmError(mmeHardwareInitialisationError).
			////////////////////////////////////////////////////////////////////////////////
			virtual void StartProjectionMode(void) = 0;

			////////////////////////////////////////////////////////////////////////////////
			/// Method stops rendering process. 
			////////////////////////////////////////////////////////////////////////////////
      virtual void StopProjectionMode(void) = 0;

			////////////////////////////////////////////////////////////////////////////////
			/// Method projects image from image sequence list.
			///
			/// @param[in] m_iImageIndex index of image in sequence list.
			////////////////////////////////////////////////////////////////////////////////
			virtual void ProjectImage(mmInt m_iImageIndex) = 0;

			////////////////////////////////////////////////////////////////////////////////
			/// Method returns projection width.
			///
			/// @return projection width.
			////////////////////////////////////////////////////////////////////////////////
			virtual mmInt GetProjectionWidth(void) = 0;
			////////////////////////////////////////////////////////////////////////////////
			/// Method returns projection height.
			///
			/// @return projection height.
			////////////////////////////////////////////////////////////////////////////////
			virtual mmInt GetProjectionHeight(void) = 0;

			////////////////////////////////////////////////////////////////////////////////
			/// Method saves projector state into XML file. It not save image sequence.
			///
			/// @param[in] p_sPathToFile path to XML file.
			////////////////////////////////////////////////////////////////////////////////
			virtual void SaveStateInXMLFile(mmString p_sPathToFile) = 0;

			////////////////////////////////////////////////////////////////////////////////
			/// Method saves projector state into XML file. It not save image sequence.
			///
			/// @param[in] p_pcPathToFile path to XML file.
			////////////////////////////////////////////////////////////////////////////////
			virtual void SaveStateInXMLFile(wchar_t* p_pcPathToFile) = 0;

			////////////////////////////////////////////////////////////////////////////////
			/// Method loads projector state from XML file.
			///
			/// @param[in] p_sPathToFile path to XML file.
			////////////////////////////////////////////////////////////////////////////////
			virtual void LoadStateFromXMLFile(mmString p_sPathToFile) = 0;

			////////////////////////////////////////////////////////////////////////////////
			/// Method loads projector state from XML file.
			///
			/// @param[in] p_pcPathToFile path to XML file.
			////////////////////////////////////////////////////////////////////////////////
			virtual void LoadStateFromXMLFile(wchar_t* p_pcPathToFile) = 0;
	};

	////////////////////////////////////////////////////////////////////////////////
	/// Projector container interface. It is responsible for
	/// searching all available projectors and querying them. It also initializes
	/// projector objects and return pointers to them.
	////////////////////////////////////////////////////////////////////////////////
	class mmProjectorContainerI
	{
		public:			// name
			////////////////////////////////////////////////////////////////////////////////
			/// Virtual destructor.
			////////////////////////////////////////////////////////////////////////////////
			virtual ~mmProjectorContainerI() {};

			////////////////////////////////////////////////////////////////////////////////
			/// Returns list with names of available projectors.
			///
			/// @return vector with names defining available projectors.
			////////////////////////////////////////////////////////////////////////////////
			virtual std::vector<mmString> GetAvailableProjectors(void) = 0;

			////////////////////////////////////////////////////////////////////////////////
			/// Initializes selected projector and returns pointer into its interface.
			/// In case of error it throws mmError(mmeHardwareUnknownDetector).
			///
			/// @param[in] p_sProjectorName name of projector to initialize,
			/// @return pointer to initialized mmHardware::mmProjectorI object.
			////////////////////////////////////////////////////////////////////////////////
			virtual mmHardware::mmProjectorI* InitializeProjector(mmString p_sProjectorName) = 0;
	};
};

#endif
