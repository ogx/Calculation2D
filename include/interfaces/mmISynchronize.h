//******************************************************************************
//******************************************************************************
//
//  Thread and data synchronize Interface
//
//
//  Description: Definition of interfaces for synchronization of data or
//							 threads.
//
//******************************************************************************
//******************************************************************************
#ifndef mmISynchronizeH
#define mmISynchronizeH

#include <mmGlobalDefs.h>
#include <mmError.h>

////////////////////////////////////////////////////////////////////////////////
/// Synchronize namespace for all synchronization objects.
////////////////////////////////////////////////////////////////////////////////
namespace mmSynchronize
{
	////////////////////////////////////////////////////////////////////////////////
	/// Interface for exclusive lock.
	////////////////////////////////////////////////////////////////////////////////
	class mmExclusiveLockI
	{
		public:   // methods
			////////////////////////////////////////////////////////////////////////////////
			/// Virtual destructor. Clean resources. In case of lock state throws error
			///	mmError(mmeExclusiveLockLocked).
			////////////////////////////////////////////////////////////////////////////////
			virtual ~mmExclusiveLockI() {};

			////////////////////////////////////////////////////////////////////////////////
			/// TryLock tries to lock.
			///
			/// @return true for success, false otherwise.
			////////////////////////////////////////////////////////////////////////////////
			virtual bool TryLock(void) = 0;

			////////////////////////////////////////////////////////////////////////////////
			/// Wait till successful lock.
			////////////////////////////////////////////////////////////////////////////////
			virtual void Lock(void) = 0;

			////////////////////////////////////////////////////////////////////////////////
			/// Unlock state. In case of unlocked state throws error
			///	mmError(mmeExclusiveLockUnlocked).
			////////////////////////////////////////////////////////////////////////////////
			virtual void Unlock(void) = 0;
	};

	////////////////////////////////////////////////////////////////////////////////
	/// Interface supporting read/write lock functionality. Gives possibility
	/// for multiple read locks and signle write lock.
	////////////////////////////////////////////////////////////////////////////////
	class mmReadWriteLockI
	{
		public:   // methods
			////////////////////////////////////////////////////////////////////////////////
			/// Virtual destructor. Clean resources. In case of bad end
			/// conditions throws exception (if it is locked then throws
			/// mmError(mmeReadWriteLockBadEndLockCount), if some object waits for write lock
			/// then throws mmError(mmeReadWriteLockWaitForWrite)).
			////////////////////////////////////////////////////////////////////////////////
			virtual ~mmReadWriteLockI() {};

			////////////////////////////////////////////////////////////////////////////////
			/// Tries to lock for read.
			///
			/// @return true for success, false otherwise.
			////////////////////////////////////////////////////////////////////////////////
			virtual bool TryLockForRead(void) = 0;

			////////////////////////////////////////////////////////////////////////////////
			/// Wait till successful read lock.
			////////////////////////////////////////////////////////////////////////////////
			virtual void LockForRead(void) = 0;

			////////////////////////////////////////////////////////////////////////////////
			/// Unlock read state. In case of unlocked state throws error
			///	mmError(mmeReadWriteLockReadUnlocked).
			////////////////////////////////////////////////////////////////////////////////
			virtual void UnlockFromRead(void) = 0;

			////////////////////////////////////////////////////////////////////////////////
			/// Tries to lock for write.
			///
			/// @return true for success, false otherwise.
			////////////////////////////////////////////////////////////////////////////////
			virtual bool TryLockForWrite(void) = 0;

			////////////////////////////////////////////////////////////////////////////////
			/// Wait till successful write lock.
			////////////////////////////////////////////////////////////////////////////////
			virtual void LockForWrite(void) = 0;

			////////////////////////////////////////////////////////////////////////////////
			/// Unlock write state. In case of unlocked state throws error
			///	mmError(mmeReadWriteLockWriteUnlocked).
			////////////////////////////////////////////////////////////////////////////////
			virtual void UnlockFromWrite(void) = 0;

			////////////////////////////////////////////////////////////////////////////////
			/// Method returns state of lock.
			///
			/// @param[out] p_pbWaitForWrite TRUE if any object waits for write access,
			///							FALSE otherwise,
			/// @return integer value representing lock state; - =-1 locked for write,
			/// =0 unlocked, =n locked for read by n objects.
			////////////////////////////////////////////////////////////////////////////////
			virtual mmInt GetLockState(bool* p_pbWaitForWrite) = 0;
	};
};

#endif
