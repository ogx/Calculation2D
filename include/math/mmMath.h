//******************************************************************************
//******************************************************************************
//
//  Description: This header defines math functionality for the system.
//
//******************************************************************************
//******************************************************************************
#ifndef mmMathH
#define mmMathH

#include <vector>
#define _USE_MATH_DEFINES 1
#include <math.h>

#include <mmGlobalDefs.h>

////////////////////////////////////////////////////////////////////////////////
/// This namespace implements math routines used in the system.
////////////////////////////////////////////////////////////////////////////////
namespace mmMath
{
	extern const mmReal g_rPI;
	extern const mmReal g_r2PI;
	extern const mmReal g_rPI_div2;
	extern const mmReal g_rPIAndMargin;

	extern const mmReal g_rMaxReal;
	extern const mmReal g_rMinReal;

	extern const mmFloat g_fMaxFloat;
	extern const mmFloat g_fMinFloat;

	extern const mmReal g_rOne;
	extern const mmReal g_rSmall;

	////////////////////////////////////////////////////////////////////////////////
	/// This structure defines two dimensional point with real coords.
	////////////////////////////////////////////////////////////////////////////////
	typedef struct
	{
		////////////////////////////////////////////////////////////////////////////////
		/// X coord.
		////////////////////////////////////////////////////////////////////////////////
		mmReal rX;
		////////////////////////////////////////////////////////////////////////////////
		/// Y coord.
		////////////////////////////////////////////////////////////////////////////////
		mmReal rY;
	} sPoint2D;

	////////////////////////////////////////////////////////////////////////////////
	/// This structure defines three dimensional point with real coords.
	////////////////////////////////////////////////////////////////////////////////
	typedef struct
	{
		////////////////////////////////////////////////////////////////////////////////
		/// X coord.
		////////////////////////////////////////////////////////////////////////////////
		mmReal rX;
		////////////////////////////////////////////////////////////////////////////////
		/// Y coord.
		////////////////////////////////////////////////////////////////////////////////
		mmReal rY;
		////////////////////////////////////////////////////////////////////////////////
		/// Z coord.
		////////////////////////////////////////////////////////////////////////////////
		mmReal rZ;
	} sPoint3D;

	////////////////////////////////////////////////////////////////////////////////
	/// This structure defines two dimensional line (y=A*x + B).
	////////////////////////////////////////////////////////////////////////////////
	typedef struct
	{
		////////////////////////////////////////////////////////////////////////////////
		/// A coefficient of line.
		////////////////////////////////////////////////////////////////////////////////
		mmReal rA;
		////////////////////////////////////////////////////////////////////////////////
		/// B coefficient of line.
		////////////////////////////////////////////////////////////////////////////////
		mmReal rB;
	} sLine2D;

	////////////////////////////////////////////////////////////////////////////////
	/// This structure defines fields required to calculate three dimensional line
	/// with real coords by MinRMS method.
	////////////////////////////////////////////////////////////////////////////////
	typedef struct
	{
		////////////////////////////////////////////////////////////////////////////////
		/// Sum of X^2.
		////////////////////////////////////////////////////////////////////////////////
		mmReal rSumX2;
		////////////////////////////////////////////////////////////////////////////////
		/// Sum of Y^2.
		////////////////////////////////////////////////////////////////////////////////
		mmReal rSumY2;
		////////////////////////////////////////////////////////////////////////////////
		/// Sum of Z^2.
		////////////////////////////////////////////////////////////////////////////////
		mmReal rSumZ2;
		////////////////////////////////////////////////////////////////////////////////
		/// Sum of X*Y.
		////////////////////////////////////////////////////////////////////////////////
		mmReal rSumXY;
		////////////////////////////////////////////////////////////////////////////////
		/// Sum of X*Z.
		////////////////////////////////////////////////////////////////////////////////
		mmReal rSumXZ;
		////////////////////////////////////////////////////////////////////////////////
		/// Sum of Y*Z.
		////////////////////////////////////////////////////////////////////////////////
		mmReal rSumYZ;
		////////////////////////////////////////////////////////////////////////////////
		/// Points count.
		////////////////////////////////////////////////////////////////////////////////
		mmReal rCount;
	} sLine3DCalc;

	////////////////////////////////////////////////////////////////////////////////
	/// Values for calculating best fitted polynomial y = ax^3 + bx^2 +cx + d
	////////////////////////////////////////////////////////////////////////////////
	typedef struct
	{
		////////////////////////////////////////////////////////////////////////////////
		/// Sum of x^6.
		////////////////////////////////////////////////////////////////////////////////
		mmReal rSumX6;
		////////////////////////////////////////////////////////////////////////////////
		/// Sum of x^5.
		////////////////////////////////////////////////////////////////////////////////
		mmReal rSumX5;
		////////////////////////////////////////////////////////////////////////////////
		/// Sum of x^4.
		////////////////////////////////////////////////////////////////////////////////
		mmReal rSumX4;
		////////////////////////////////////////////////////////////////////////////////
		/// Sum of x^3.
		////////////////////////////////////////////////////////////////////////////////
		mmReal rSumX3;
		////////////////////////////////////////////////////////////////////////////////
		/// Sum of x^2.
		////////////////////////////////////////////////////////////////////////////////
		mmReal rSumX2;
		////////////////////////////////////////////////////////////////////////////////
		/// Sum of x.
		////////////////////////////////////////////////////////////////////////////////
		mmReal rSumX;
		////////////////////////////////////////////////////////////////////////////////
		/// Sum of (x^3)*y.
		////////////////////////////////////////////////////////////////////////////////
		mmReal rSumX3Y;
		////////////////////////////////////////////////////////////////////////////////
		/// Sum of (x^2)*y.
		////////////////////////////////////////////////////////////////////////////////
		mmReal rSumX2Y;
		////////////////////////////////////////////////////////////////////////////////
		/// Sum of xy.
		////////////////////////////////////////////////////////////////////////////////
		mmReal rSumXY;
		////////////////////////////////////////////////////////////////////////////////
		/// Sum of y.
		////////////////////////////////////////////////////////////////////////////////
		mmReal rSumY;
		////////////////////////////////////////////////////////////////////////////////
		/// Points count.
		////////////////////////////////////////////////////////////////////////////////
		mmReal rCount;
	} s3OrderPolynomialXtoYCalc;

	////////////////////////////////////////////////////////////////////////////////
	/// Definition of polynomial y = ax^3 + bx^2 +cx + d
	////////////////////////////////////////////////////////////////////////////////
	typedef struct
	{
		////////////////////////////////////////////////////////////////////////////////
		/// A coefficient.
		////////////////////////////////////////////////////////////////////////////////
		mmReal rA;
		////////////////////////////////////////////////////////////////////////////////
		/// B coefficient.
		////////////////////////////////////////////////////////////////////////////////
		mmReal rB;
		////////////////////////////////////////////////////////////////////////////////
		/// C coefficient.
		////////////////////////////////////////////////////////////////////////////////
		mmReal rC;
		////////////////////////////////////////////////////////////////////////////////
		/// D coefficient.
		////////////////////////////////////////////////////////////////////////////////
		mmReal rD;
	} s3OrderPolynomialXtoY;

	////////////////////////////////////////////////////////////////////////////////
	/// This structure defines three dimensional line (x-x0)/A = (y-y0)/B = (z-z0)/C.
	////////////////////////////////////////////////////////////////////////////////
	typedef struct
	{
		////////////////////////////////////////////////////////////////////////////////
		/// A coefficient of line.
		////////////////////////////////////////////////////////////////////////////////
		mmReal rA;
		////////////////////////////////////////////////////////////////////////////////
		/// B coefficient of line.
		////////////////////////////////////////////////////////////////////////////////
		mmReal rB;
		////////////////////////////////////////////////////////////////////////////////
		/// C coefficient of line.
		////////////////////////////////////////////////////////////////////////////////
		mmReal rC;
		////////////////////////////////////////////////////////////////////////////////
    /// Point on line.
		////////////////////////////////////////////////////////////////////////////////
		sPoint3D sP;
	} sLine3D;

	////////////////////////////////////////////////////////////////////////////////
	/// This structure defines fields required to calculate three dimensional plane
	/// with real coords by MinRMS method.
	////////////////////////////////////////////////////////////////////////////////
	typedef struct
	{
		////////////////////////////////////////////////////////////////////////////////
		/// Sum of X^2.
		////////////////////////////////////////////////////////////////////////////////
		mmReal rSumX2;
		////////////////////////////////////////////////////////////////////////////////
		/// Sum of Y^2.
		////////////////////////////////////////////////////////////////////////////////
		mmReal rSumY2;
		////////////////////////////////////////////////////////////////////////////////
		/// Sum of Z^2.
		////////////////////////////////////////////////////////////////////////////////
		mmReal rSumZ2;
		////////////////////////////////////////////////////////////////////////////////
		/// Sum of X*Y.
		////////////////////////////////////////////////////////////////////////////////
		mmReal rSumXY;
		////////////////////////////////////////////////////////////////////////////////
		/// Sum of X*Z.
		////////////////////////////////////////////////////////////////////////////////
		mmReal rSumXZ;
		////////////////////////////////////////////////////////////////////////////////
		/// Sum of Y*Z.
		////////////////////////////////////////////////////////////////////////////////
		mmReal rSumYZ;
		////////////////////////////////////////////////////////////////////////////////
		/// Sum of X.
		////////////////////////////////////////////////////////////////////////////////
		mmReal rSumX;
		////////////////////////////////////////////////////////////////////////////////
		/// Sum of Y.
		////////////////////////////////////////////////////////////////////////////////
		mmReal rSumY;
		////////////////////////////////////////////////////////////////////////////////
		/// Sum of Z.
		////////////////////////////////////////////////////////////////////////////////
		mmReal rSumZ;
		////////////////////////////////////////////////////////////////////////////////
		/// Points count.
		////////////////////////////////////////////////////////////////////////////////
		mmReal rCount;
	} sPlane3DCalc;

	////////////////////////////////////////////////////////////////////////////////
	/// This structure defines plane formula.
	////////////////////////////////////////////////////////////////////////////////
	typedef struct
	{
		////////////////////////////////////////////////////////////////////////////////
		/// A coefficient of plane.
		////////////////////////////////////////////////////////////////////////////////
		mmReal rA;
		////////////////////////////////////////////////////////////////////////////////
		/// B coefficient of plane.
		////////////////////////////////////////////////////////////////////////////////
		mmReal rB;
		////////////////////////////////////////////////////////////////////////////////
		/// C coefficient of plane.
		////////////////////////////////////////////////////////////////////////////////
		mmReal rC;
		////////////////////////////////////////////////////////////////////////////////
		/// D coefficient of plane.
		////////////////////////////////////////////////////////////////////////////////
		mmReal rD;
	} sPlane3D;

	////////////////////////////////////////////////////////////////////////////////
	/// This structure defines fields required to calculate two dimensional circle
	/// with real coords by MinRMS method.
	////////////////////////////////////////////////////////////////////////////////
	typedef struct
	{
		////////////////////////////////////////////////////////////////////////////////
		/// Sum of X^3.
		////////////////////////////////////////////////////////////////////////////////
		mmReal rSumX3;
		////////////////////////////////////////////////////////////////////////////////
		/// Sum of X^2*Y.
		////////////////////////////////////////////////////////////////////////////////
		mmReal rSumX2Y;
		////////////////////////////////////////////////////////////////////////////////
		/// Sum of X*Y^2.
		////////////////////////////////////////////////////////////////////////////////
		mmReal rSumXY2;
		////////////////////////////////////////////////////////////////////////////////
		/// Sum of Y^3.
		////////////////////////////////////////////////////////////////////////////////
		mmReal rSumY3;
		////////////////////////////////////////////////////////////////////////////////
		/// Sum of X^2.
		////////////////////////////////////////////////////////////////////////////////
		mmReal rSumX2;
		////////////////////////////////////////////////////////////////////////////////
		/// Sum of X*Y.
		////////////////////////////////////////////////////////////////////////////////
		mmReal rSumXY;
		////////////////////////////////////////////////////////////////////////////////
		/// Sum of Y^2.
		////////////////////////////////////////////////////////////////////////////////
		mmReal rSumY2;
		////////////////////////////////////////////////////////////////////////////////
		/// Sum of X.
		////////////////////////////////////////////////////////////////////////////////
		mmReal rSumX;
		////////////////////////////////////////////////////////////////////////////////
		/// Sum of Y.
		////////////////////////////////////////////////////////////////////////////////
		mmReal rSumY;
		////////////////////////////////////////////////////////////////////////////////
		/// Pixels/points count.
		////////////////////////////////////////////////////////////////////////////////
		mmReal rCount;
	} sCircle2DCalc;

	////////////////////////////////////////////////////////////////////////////////
	/// This structure defines fields required to calculate three dimensional sphere
	/// with real coords by MinRMS method.
	////////////////////////////////////////////////////////////////////////////////
	typedef struct
	{
		////////////////////////////////////////////////////////////////////////////////
		/// Sum of X^3.
		////////////////////////////////////////////////////////////////////////////////
		mmReal rSumX3;
		////////////////////////////////////////////////////////////////////////////////
		/// Sum of X^2*Y.
		////////////////////////////////////////////////////////////////////////////////
		mmReal rSumX2Y;
		////////////////////////////////////////////////////////////////////////////////
		/// Sum of X^2*Z.
		////////////////////////////////////////////////////////////////////////////////
		mmReal rSumX2Z;
		////////////////////////////////////////////////////////////////////////////////
		/// Sum of X*Y^2.
		////////////////////////////////////////////////////////////////////////////////
		mmReal rSumXY2;
		////////////////////////////////////////////////////////////////////////////////
		/// Sum of X*Z^2.
		////////////////////////////////////////////////////////////////////////////////
		mmReal rSumXZ2;
		////////////////////////////////////////////////////////////////////////////////
		/// Sum of Y^2*Z.
		////////////////////////////////////////////////////////////////////////////////
		mmReal rSumY2Z;
		////////////////////////////////////////////////////////////////////////////////
		/// Sum of Y*Z^2.
		////////////////////////////////////////////////////////////////////////////////
		mmReal rSumYZ2;
		////////////////////////////////////////////////////////////////////////////////
		/// Sum of Y^3.
		////////////////////////////////////////////////////////////////////////////////
		mmReal rSumY3;
		////////////////////////////////////////////////////////////////////////////////
		/// Sum of Z^3.
		////////////////////////////////////////////////////////////////////////////////
		mmReal rSumZ3;
		////////////////////////////////////////////////////////////////////////////////
		/// Sum of X^2.
		////////////////////////////////////////////////////////////////////////////////
		mmReal rSumX2;
		////////////////////////////////////////////////////////////////////////////////
		/// Sum of X*Y.
		////////////////////////////////////////////////////////////////////////////////
		mmReal rSumXY;
		////////////////////////////////////////////////////////////////////////////////
		/// Sum of X*Z.
		////////////////////////////////////////////////////////////////////////////////
		mmReal rSumXZ;
		////////////////////////////////////////////////////////////////////////////////
		/// Sum of Y*Z.
		////////////////////////////////////////////////////////////////////////////////
		mmReal rSumYZ;
		////////////////////////////////////////////////////////////////////////////////
		/// Sum of Y^2.
		////////////////////////////////////////////////////////////////////////////////
		mmReal rSumY2;
		////////////////////////////////////////////////////////////////////////////////
		/// Sum of Z^2.
		////////////////////////////////////////////////////////////////////////////////
		mmReal rSumZ2;
		////////////////////////////////////////////////////////////////////////////////
		/// Sum of X.
		////////////////////////////////////////////////////////////////////////////////
		mmReal rSumX;
		////////////////////////////////////////////////////////////////////////////////
		/// Sum of Y.
		////////////////////////////////////////////////////////////////////////////////
		mmReal rSumY;
		////////////////////////////////////////////////////////////////////////////////
		/// Sum of Z.
		////////////////////////////////////////////////////////////////////////////////
		mmReal rSumZ;
		////////////////////////////////////////////////////////////////////////////////
		/// Pixels/points count.
		////////////////////////////////////////////////////////////////////////////////
		mmReal rCount;
	} sSphere3DCalc;

	////////////////////////////////////////////////////////////////////////////////
	/// This structure defines three dimensional sphere with real coords.
	////////////////////////////////////////////////////////////////////////////////
	typedef struct
	{
		////////////////////////////////////////////////////////////////////////////////
		/// X coord of sphere center.
		////////////////////////////////////////////////////////////////////////////////
		mmReal rX0;
		////////////////////////////////////////////////////////////////////////////////
		/// Y coord of sphere center.
		////////////////////////////////////////////////////////////////////////////////
		mmReal rY0;
		////////////////////////////////////////////////////////////////////////////////
		/// Z coord of sphere center.
		////////////////////////////////////////////////////////////////////////////////
		mmReal rZ0;
		////////////////////////////////////////////////////////////////////////////////
		/// Radius of sphere.
		////////////////////////////////////////////////////////////////////////////////
		mmReal rRadius;
	} sSphere3D;

	////////////////////////////////////////////////////////////////////////////////
	/// This structure defines two dimensional circle with real coords.
	////////////////////////////////////////////////////////////////////////////////
	typedef struct
	{
		////////////////////////////////////////////////////////////////////////////////
		/// X coord of circle center.
		////////////////////////////////////////////////////////////////////////////////
		mmReal rX0;
		////////////////////////////////////////////////////////////////////////////////
		/// Y coord of circle center.
		////////////////////////////////////////////////////////////////////////////////
		mmReal rY0;
		////////////////////////////////////////////////////////////////////////////////
		/// Radius of circle.
		////////////////////////////////////////////////////////////////////////////////
		mmReal rRadius;
	} sCircle2D;

	typedef struct
	{
		////////////////////////////////////////////////////////////////////////////////
		/// X coord of circle center.
		////////////////////////////////////////////////////////////////////////////////
		mmReal rX0;
		////////////////////////////////////////////////////////////////////////////////
		/// Y coord of circle center.
		////////////////////////////////////////////////////////////////////////////////
		mmReal rY0;
		////////////////////////////////////////////////////////////////////////////////
		/// Z coord of circle center.
		////////////////////////////////////////////////////////////////////////////////
		mmReal rZ0;
		////////////////////////////////////////////////////////////////////////////////
		/// Radius of circle.
		////////////////////////////////////////////////////////////////////////////////
		mmReal rRadius;
		////////////////////////////////////////////////////////////////////////////////
		/// X coord of normal vector to circle plane.
		////////////////////////////////////////////////////////////////////////////////
		mmReal rA;
		////////////////////////////////////////////////////////////////////////////////
		/// Y coord of normal vector to circle plane.
		////////////////////////////////////////////////////////////////////////////////
		mmReal rB;
		////////////////////////////////////////////////////////////////////////////////
		/// Z coord of normal vector to circle plane.
		////////////////////////////////////////////////////////////////////////////////
		mmReal rC;
		mmReal rPlaneError;
		mmReal rCircleError;
	} sCircle3D;

	////////////////////////////////////////////////////////////////////////////////
	/// This structure defines fields required to calculate two dimensional ellipse
	/// with real coords by MinRMS method.
	////////////////////////////////////////////////////////////////////////////////
	typedef struct
	{
  	////////////////////////////////////////////////////////////////////////////////
		/// Sum of X^4.
		////////////////////////////////////////////////////////////////////////////////
		mmReal rSumX4;
		////////////////////////////////////////////////////////////////////////////////
		/// Sum of X^3*Y.
		////////////////////////////////////////////////////////////////////////////////
		mmReal rSumX3Y;
		////////////////////////////////////////////////////////////////////////////////
		/// Sum of X^2*Y^2.
		////////////////////////////////////////////////////////////////////////////////
		mmReal rSumX2Y2;
		////////////////////////////////////////////////////////////////////////////////
		/// Sum of X*Y^3.
		////////////////////////////////////////////////////////////////////////////////
		mmReal rSumXY3;
		////////////////////////////////////////////////////////////////////////////////
		/// Sum of Y^4.
		////////////////////////////////////////////////////////////////////////////////
		mmReal rSumY4;
		////////////////////////////////////////////////////////////////////////////////
		/// Sum of X^3.
		////////////////////////////////////////////////////////////////////////////////
		mmReal rSumX3;
		////////////////////////////////////////////////////////////////////////////////
		/// Sum of X^2*Y.
		////////////////////////////////////////////////////////////////////////////////
		mmReal rSumX2Y;
		////////////////////////////////////////////////////////////////////////////////
		/// Sum of X*Y^2.
		////////////////////////////////////////////////////////////////////////////////
		mmReal rSumXY2;
		////////////////////////////////////////////////////////////////////////////////
		/// Sum of Y^3.
		////////////////////////////////////////////////////////////////////////////////
		mmReal rSumY3;
		////////////////////////////////////////////////////////////////////////////////
		/// Sum of X^2.
		////////////////////////////////////////////////////////////////////////////////
		mmReal rSumX2;
		////////////////////////////////////////////////////////////////////////////////
		/// Sum of X*Y.
		////////////////////////////////////////////////////////////////////////////////
		mmReal rSumXY;
		////////////////////////////////////////////////////////////////////////////////
		/// Sum of Y^2.
		////////////////////////////////////////////////////////////////////////////////
		mmReal rSumY2;
		////////////////////////////////////////////////////////////////////////////////
		/// Sum of X.
		////////////////////////////////////////////////////////////////////////////////
		mmReal rSumX;
		////////////////////////////////////////////////////////////////////////////////
		/// Sum of Y.
		////////////////////////////////////////////////////////////////////////////////
		mmReal rSumY;
		////////////////////////////////////////////////////////////////////////////////
		/// Pixels/points count.
		////////////////////////////////////////////////////////////////////////////////
		mmReal rCount;
	} sEllipse2DCalc;

	////////////////////////////////////////////////////////////////////////////////
	/// This structure defines two dimensional ellipse with real coords.
	////////////////////////////////////////////////////////////////////////////////
	typedef struct
	{
		////////////////////////////////////////////////////////////////////////////////
		/// X coord of ellipse center.
		////////////////////////////////////////////////////////////////////////////////
		mmReal rX0;
		////////////////////////////////////////////////////////////////////////////////
		/// Y coord of ellipse center.
		////////////////////////////////////////////////////////////////////////////////
		mmReal rY0;
		////////////////////////////////////////////////////////////////////////////////
		/// Rotation angle of ellipse.
		////////////////////////////////////////////////////////////////////////////////
		mmReal rAngle;
		////////////////////////////////////////////////////////////////////////////////
		/// Radius in x axis of ellipse.
		////////////////////////////////////////////////////////////////////////////////
		mmReal rRadiusA;
		////////////////////////////////////////////////////////////////////////////////
		/// Radius in y axis of ellipse.
		////////////////////////////////////////////////////////////////////////////////
		mmReal rRadiusB;
		////////////////////////////////////////////////////////////////////////////////
		/// Coefficient of canonical form a: a*x^2 + b*2*x*y + c*y^2 + d*x + e*y + f = 0
		////////////////////////////////////////////////////////////////////////////////
		mmReal rA;
		////////////////////////////////////////////////////////////////////////////////
		/// Coefficient of canonical form b: a*x^2 + b*2*x*y + c*y^2 + d*x + e*y + f = 0
		////////////////////////////////////////////////////////////////////////////////
		mmReal rB;
		////////////////////////////////////////////////////////////////////////////////
		/// Coefficient of canonical form c: a*x^2 + b*2*x*y + c*y^2 + d*x + e*y + f = 0
		////////////////////////////////////////////////////////////////////////////////
		mmReal rC;
		////////////////////////////////////////////////////////////////////////////////
		/// Coefficient of canonical form d: a*x^2 + b*2*x*y + c*y^2 + d*x + e*y + f = 0
		////////////////////////////////////////////////////////////////////////////////
		mmReal rD;
		////////////////////////////////////////////////////////////////////////////////
		/// Coefficient of canonical form e: a*x^2 + b*2*x*y + c*y^2 + d*x + e*y + f = 0
		////////////////////////////////////////////////////////////////////////////////
		mmReal rE;
		////////////////////////////////////////////////////////////////////////////////
		/// Coefficient of canonical form f: a*x^2 + b*2*x*y + c*y^2 + d*x + e*y + f = 0
		////////////////////////////////////////////////////////////////////////////////
		mmReal rF;
	} sEllipse2D;

	////////////////////////////////////////////////////////////////////////////////
	/// This structure defines 3D transformation.
	////////////////////////////////////////////////////////////////////////////////
	typedef struct
	{
		////////////////////////////////////////////////////////////////////////////////
		/// X translation.
		////////////////////////////////////////////////////////////////////////////////
		mmReal rTranslationX;
		////////////////////////////////////////////////////////////////////////////////
		/// Y translation.
		////////////////////////////////////////////////////////////////////////////////
		mmReal rTranslationY;
		////////////////////////////////////////////////////////////////////////////////
		/// Z translation.
		////////////////////////////////////////////////////////////////////////////////
		mmReal rTranslationZ;
		////////////////////////////////////////////////////////////////////////////////
		/// X rotation.
		////////////////////////////////////////////////////////////////////////////////
		mmReal rRotationX;
		////////////////////////////////////////////////////////////////////////////////
		/// Y rotation.
		////////////////////////////////////////////////////////////////////////////////
		mmReal rRotationY;
		////////////////////////////////////////////////////////////////////////////////
		/// Z rotation.
		////////////////////////////////////////////////////////////////////////////////
		mmReal rRotationZ;
		////////////////////////////////////////////////////////////////////////////////
		/// X rotation sin+.
		////////////////////////////////////////////////////////////////////////////////
		mmReal rRotationXSinP;
		////////////////////////////////////////////////////////////////////////////////
		/// X rotation sin-.
		////////////////////////////////////////////////////////////////////////////////
		mmReal rRotationXSinM;
		////////////////////////////////////////////////////////////////////////////////
		/// X rotation cos+.
		////////////////////////////////////////////////////////////////////////////////
		mmReal rRotationXCosP;
		////////////////////////////////////////////////////////////////////////////////
		/// X rotation cos-.
		////////////////////////////////////////////////////////////////////////////////
		mmReal rRotationXCosM;
		////////////////////////////////////////////////////////////////////////////////
		/// Y rotation sin+.
		////////////////////////////////////////////////////////////////////////////////
		mmReal rRotationYSinP;
		////////////////////////////////////////////////////////////////////////////////
		/// Y rotation sin-.
		////////////////////////////////////////////////////////////////////////////////
		mmReal rRotationYSinM;
		////////////////////////////////////////////////////////////////////////////////
		/// Y rotation cos+.
		////////////////////////////////////////////////////////////////////////////////
		mmReal rRotationYCosP;
		////////////////////////////////////////////////////////////////////////////////
		/// Y rotation cos-.
		////////////////////////////////////////////////////////////////////////////////
		mmReal rRotationYCosM;
		////////////////////////////////////////////////////////////////////////////////
		/// Z rotation sin+.
		////////////////////////////////////////////////////////////////////////////////
		mmReal rRotationZSinP;
		////////////////////////////////////////////////////////////////////////////////
		/// Z rotation sin-.
		////////////////////////////////////////////////////////////////////////////////
		mmReal rRotationZSinM;
		////////////////////////////////////////////////////////////////////////////////
		/// Z rotation cos+.
		////////////////////////////////////////////////////////////////////////////////
		mmReal rRotationZCosP;
		////////////////////////////////////////////////////////////////////////////////
		/// Z rotation cos-.
		////////////////////////////////////////////////////////////////////////////////
		mmReal rRotationZCosM;
	} s3DTransformation;

	////////////////////////////////////////////////////////////////////////////////
	/// This structure defines point set.
	////////////////////////////////////////////////////////////////////////////////
	typedef struct
	{
		////////////////////////////////////////////////////////////////////////////////
		/// Vector of pont indexes.
		////////////////////////////////////////////////////////////////////////////////
		std::vector<mmInt> vIndexes;
	} sFittingPoints;

	////////////////////////////////////////////////////////////////////////////////
	/// Function solves set of linear equations. All fields of table p_sTB have to be
	/// non zeros.
	///
	/// @param[in] p_psTA input table (size p_iN*p_iN)
	/// @param[in,out] p_psTB input/output table (size p_iN)
	/// @param[in] p_iN size of tables
	////////////////////////////////////////////////////////////////////////////////
	void SolveSetOfLinearEquations(mmReal* p_psTA,
																 mmReal* p_psTB,
																 mmInt p_iN);

	////////////////////////////////////////////////////////////////////////////////
	/// Function returns smallest power of 2 but bigger than input number.
	///
	/// @param[in] p_iInputValue input number
	/// @return bigger smallest power of 2
	////////////////////////////////////////////////////////////////////////////////
	mmInt GetSmallestsBiggerPowerOf2(mmInt p_iInputValue);

	////////////////////////////////////////////////////////////////////////////////
	/// Function calculates vector product in 3D.
	///
	/// @param[in] p_sVec1 input vector 1
	/// @param[in] p_sVec2 input vector 2
	/// @return vector
	////////////////////////////////////////////////////////////////////////////////
	mmMath::sPoint3D CalcVectorProduct3D(mmMath::sPoint3D p_sVec1,
																			 mmMath::sPoint3D p_sVec2);

	////////////////////////////////////////////////////////////////////////////////
	/// Function calculates circle by minimum RMS criterion.
	///
	/// @param[in] p_sCircle2DParams calculated params of circle
	/// @return circle definition
	////////////////////////////////////////////////////////////////////////////////
	mmMath::sCircle2D CalcCircle2DFormulaByMinRMS(sCircle2DCalc p_sCircle2DParams);

	////////////////////////////////////////////////////////////////////////////////
	/// Function calculates RMS value from set of distances between p_sPoint3D point
	///	and each point in vector pointed by p_pvInPoints.
	///
	/// @param[in] p_sPoint3D input point,
	/// @param[in] p_pvInPoints pointer to vector of points,
	/// @return RMS value calculated.
	////////////////////////////////////////////////////////////////////////////////
	mmReal CalcPoint3DToPointsRMSError(mmMath::sPoint3D p_sPoint3D,
																		 std::vector<mmMath::sPoint3D>* p_pvInPoints);

	////////////////////////////////////////////////////////////////////////////////
	/// Function calculates RMS value from set of distances between circle center
	/// p_sPoint3D point and each point in vector pointed by p_pvInPoints representing
	/// points on circumference of a circle. Radius is calculated on base of square
	/// root average sum of distances from circle center and rest of points.
	///
	/// @param[in] p_sPoint3D circle center,
	/// @param[in] p_pvInPoints pointer to vector of points on circumference of a crcle,
	/// @return RMS value calculated.
	////////////////////////////////////////////////////////////////////////////////
	mmReal CalcCircle3DCenterToPointsRMSError(mmMath::sPoint3D p_sPoint3D,
																						std::vector<mmMath::sPoint3D>* p_pvInPoints);

	////////////////////////////////////////////////////////////////////////////////
	/// Function calculates formula of circle 3D on base of ponts stored in vector.
	///
	/// @param[in] p_pvInPoints pointer to vector of points on circumference of a crcle,
	/// @return circle 3D formula calculated.
	////////////////////////////////////////////////////////////////////////////////
	mmMath::sCircle3D CalcCircle3DFormulaByMinRMS(std::vector<mmMath::sPoint3D>* p_pvInPoints);

	////////////////////////////////////////////////////////////////////////////////
	/// Function calculates sphere by minimum RMS criterion.
	///
	/// @param[in] p_psSphere3DParams calculated params of sphere,
	/// @return sphere definition.
	////////////////////////////////////////////////////////////////////////////////
	mmMath::sSphere3D CalcSphere3DFormulaByMinRMS(sSphere3DCalc* p_psSphere3DParams);

	////////////////////////////////////////////////////////////////////////////////
	/// Function calculates sphere by minimum RMS criterion.
	///
	/// @param[in] p_pvInPoints pointer to vector of points representing sphere,
	/// @return sphere definition.
	////////////////////////////////////////////////////////////////////////////////
	mmMath::sSphere3D CalcSphere3DFormulaByMinRMS(std::vector<mmMath::sPoint3D>* p_pvInPoints);

	////////////////////////////////////////////////////////////////////////////////
	/// Function calculates ellipse by minimum RMS criterion.
	///
	/// @param[in] p_sEllipse2DParams calculated params of ellipse
	/// @return ellipse definition
	////////////////////////////////////////////////////////////////////////////////
	mmMath::sEllipse2D CalcEllipse2DFormulaByMinRMS(sEllipse2DCalc p_sEllipse2DParams);

	////////////////////////////////////////////////////////////////////////////////
	/// Function calculates 2D line formula from two points.
	///
	/// @param[in] p_sPoint1 point of line
	/// @param[in] p_sPoint2 point of line
	/// @return line definition
	////////////////////////////////////////////////////////////////////////////////
	mmMath::sLine2D CalcLine2D(mmMath::sPoint2D p_sPoint1,
														 mmMath::sPoint2D p_sPoint2);

	////////////////////////////////////////////////////////////////////////////////
	/// Function calculates 3D line formula from two points.
	///
	/// @param[in] p_sPoint1 point of line
	/// @param[in] p_sPoint2 point of line
	/// @return line definition
	////////////////////////////////////////////////////////////////////////////////
	mmMath::sLine3D CalcLine3D(mmMath::sPoint3D p_sPoint1,
														 mmMath::sPoint3D p_sPoint2);

	////////////////////////////////////////////////////////////////////////////////
	/// Function calculates 3D line formula from many points. If A=B=C=0 then
	///	line calculation error.
	///
	/// @param[in] p_pvPoints pointer to vector with 3D points,
	/// @param[out] p_psLineFormula line formula,
	/// @return TRUE if success, FALSE otherwise.
	////////////////////////////////////////////////////////////////////////////////
	bool CalcBestLine3D(std::vector<mmMath::sPoint3D>* p_pvPoints,
											mmMath::sLine3D* p_psLineFormula);

	////////////////////////////////////////////////////////////////////////////////
	/// Function calculates 3D line formula from precalculated sphere calc params
	/// and central point (point of line).
	///
	/// @param[in] p_sLineCalcValues precalculated values for line formula calculation,
	/// @param[in] p_sCentralPoint point of line (in most cases average point),
	/// @param[out] p_psLineFormula line formula,
	/// @return TRUE if success, FALSE otherwise
	////////////////////////////////////////////////////////////////////////////////
	bool CalcBestLine3D(mmMath::sLine3DCalc p_sLineCalcValues,
											mmMath::sPoint3D p_sCentralPoint,
											mmMath::sLine3D* p_psLineFormula);

	////////////////////////////////////////////////////////////////////////////////
	/// Function calculates 3D plane formula from three points.
	///
	/// @param[in] p_sPoint1 point of plane
	/// @param[in] p_sPoint2 point of plane
	/// @param[in] p_sPoint3 point of plane
	/// @return plane formula
	////////////////////////////////////////////////////////////////////////////////
	mmMath::sPlane3D CalcPlane3D(mmMath::sPoint3D p_sPoint1,
															 mmMath::sPoint3D p_sPoint2,
															 mmMath::sPoint3D p_sPoint3);

	////////////////////////////////////////////////////////////////////////////////
	/// Function calculates 3D plane formula from point and vector.
	///
	/// @param[in] p_sPoint point of plane
	/// @param[in] p_sVector normal vector of plane
	/// @return plane formula
	////////////////////////////////////////////////////////////////////////////////
	mmMath::sPlane3D CalcPlane3D(mmMath::sPoint3D p_sPoint,
															 mmMath::sPoint3D p_sVector);

	////////////////////////////////////////////////////////////////////////////////
	/// Function calculates 3D plane formula from set of points.
	///
	/// @param[in] p_vPoints vector with points for plane calculation
	/// @param[out] p_prError if not NULL the plane fitting RMS error
	/// @return plane formula
	////////////////////////////////////////////////////////////////////////////////
	mmMath::sPlane3D CalcBestPlane3D(std::vector<mmMath::sPoint3D> p_vPoints,
																	 mmReal* p_prError = NULL);

	////////////////////////////////////////////////////////////////////////////////
	/// Function calculates 3D plane formula from set of points.
	///
	/// @param[in] p_prInXYZPoints ponter to array of (x,y,z) points for plane calculation
	/// @param[in] p_iXYZPointsCount point count n array p_prInXYZPoints
	/// @param[out] p_prError if not NULL the plane fitting RMS error
	/// @param[out] p_prMaxError if not NULL the plane fitting maximum error
	/// @return plane formula
	////////////////////////////////////////////////////////////////////////////////
	mmMath::sPlane3D CalcBestPlane3D(mmReal* p_prInXYZPoints,
																	 mmInt p_iXYZPointsCount,
																	 mmReal* p_prError = NULL,
																	 mmReal* p_prMaxError = NULL);

	////////////////////////////////////////////////////////////////////////////////
	/// Function calculates 3D plane formula from a precalculated structure.
	///
	/// @param[in] p_psPlaneCalcParams pointer to precalculated mmMath::sPlane3DCalc
	///						 structure
	/// @return vector with possible plane formulas
	////////////////////////////////////////////////////////////////////////////////
	std::vector<mmMath::sPlane3D> CalcBestPossiblePlanes3D(mmMath::sPlane3DCalc* p_psPlaneCalcParams);

	////////////////////////////////////////////////////////////////////////////////
	/// Function calculates 3D point projection on 3D plane.
	///
	/// @param[in] p_sPlane3D input plane formula
	/// @param[in] p_sPoint3D input point coordinates
	/// @return point coordinates
	////////////////////////////////////////////////////////////////////////////////
	mmMath::sPoint3D CalcPoint3DProjectionOnPlane3D(mmMath::sPlane3D p_sPlane3D,
																									mmMath::sPoint3D p_sPoint3D);

	////////////////////////////////////////////////////////////////////////////////
	/// Function calculates 3D point representing intersection of two 3D lines.
	/// In case of not crossed lines the closest point to these two lines is
	/// returned.
	///
	/// @param[in] p_sLine1 input first line formula
	/// @param[in] p_sLine2 input second line formula
	/// @param[out] p_psPoint coordnates of calculated point
	/// @return TRUE if success, FALSE otherwise
	////////////////////////////////////////////////////////////////////////////////
	bool CalcLinesIntersection2D(mmMath::sLine2D p_sLine1,
															 mmMath::sLine2D p_sLine2,
															 mmMath::sPoint2D* p_psPoint);

	////////////////////////////////////////////////////////////////////////////////
	/// Function calculates two points from two lines. These points are closest
	///	 to other line and laying on one line.
	///
	/// @param[in] p_sLine1 first line
	/// @param[in] p_sLine2 second line
	/// @param[out] p_psPointOnLine1 resultant point from line 1
	/// @param[out] p_psPointOnLine2 resultant point from line 2
	/// @return TRUE if success, FALSE otherwise
	////////////////////////////////////////////////////////////////////////////////
	bool CalcLineToLineClosestPoints(mmMath::sLine3D p_sLine1,
																	 mmMath::sLine3D p_sLine2,
																	 mmMath::sPoint3D* p_psPointOnLine1,
																	 mmMath::sPoint3D* p_psPointOnLine2);

	////////////////////////////////////////////////////////////////////////////////
	/// Function calculates 3D distance between line and point.
	///
	/// @param[in] p_sPoint point
	/// @param[in] p_sLine line
	/// @return distance
	////////////////////////////////////////////////////////////////////////////////
	mmReal CalcPointToLineDistance3D(mmMath::sPoint3D p_sPoint,
																	 mmMath::sLine3D p_sLine);

	////////////////////////////////////////////////////////////////////////////////
	/// Function calculates 3D distance between plane and point.
	///
	/// @param[in] p_sPoint3D point
	/// @param[in] p_sPlane3D line
	/// @return distance
	////////////////////////////////////////////////////////////////////////////////
	mmReal CalcPointToPlaneDistance3D(mmMath::sPoint3D p_sPoint3D,
																		mmMath::sPlane3D p_sPlane3D);

	////////////////////////////////////////////////////////////////////////////////
	/// Function calculates 3D point projection on 3D line.
	///
	/// @param[in] p_sPoint input point coordinates
	/// @param[in] p_sLine input line formula
	/// @return point coordinates
	////////////////////////////////////////////////////////////////////////////////
	mmMath::sPoint3D CalcPoint3DProjectionOnLine3D(mmMath::sPoint3D p_sPoint,
																								 mmMath::sLine3D p_sLine);

	////////////////////////////////////////////////////////////////////////////////
	/// Function calculates 3D distance between point and point.
	///
	/// @param[in] p_sPoint1 point 1
	/// @param[in] p_sPoint2 point 2
	/// @return distance
	////////////////////////////////////////////////////////////////////////////////
	mmReal CalcPointToPointDistance3D(mmMath::sPoint3D p_sPoint1,
																		mmMath::sPoint3D p_sPoint2);

	////////////////////////////////////////////////////////////////////////////////
	/// Function calculates 3D distance between point and point.
	///
	/// @param[in] p_rPoint1X point 1 x coord
	/// @param[in] p_rPoint1Y point 1 y coord
	/// @param[in] p_rPoint1Z point 1 z coord
	/// @param[in] p_sPoint2X point 2 x coord
	/// @param[in] p_sPoint2Y point 2 y coord
	/// @param[in] p_sPoint2Z point 2 z coord
	/// @return distance
	////////////////////////////////////////////////////////////////////////////////
	mmReal CalcPointToPointDistance3D(mmReal p_rPoint1X,
																		mmReal p_rPoint1Y,
																		mmReal p_rPoint1Z,
																		mmReal p_rPoint2X,
																		mmReal p_rPoint2Y,
																		mmReal p_rPoint2Z);

	////////////////////////////////////////////////////////////////////////////////
	/// Function calculates 3D vector length.
	///
	/// @param[in] p_sVector vector coordinates
	/// @return vector length
	////////////////////////////////////////////////////////////////////////////////
	mmReal CalcVector3DLength(mmMath::sPoint3D p_sVector);

	////////////////////////////////////////////////////////////////////////////////
	/// Function normalizes coordinates of 3D vector.
	///
	/// @param[in] p_sInVector input vector coordinates
	/// @return normalzed vector
	////////////////////////////////////////////////////////////////////////////////
	mmMath::sPoint3D NormalizeVector3D(mmMath::sPoint3D p_sInVector);

	////////////////////////////////////////////////////////////////////////////////
	/// Function calculates point after transformation.
	///
	/// @param[in] p_psPoint pointer to point
	/// @param[in] p_psTransformation pointer to transformation matrix
	/// @return calculated point
	////////////////////////////////////////////////////////////////////////////////
	mmMath::sPoint3D TransformPoint(mmMath::sPoint3D* p_psPoint,
																	mmMath::s3DTransformation* p_psTransformation);

	////////////////////////////////////////////////////////////////////////////////
	/// Function calculates point after transformation using pre-calculated rotations.
	///
	/// @param[in] p_psPoint pointer to point
	/// @param[in] p_psTransformation pointer to transformation matrix
	/// @return calculated point
	////////////////////////////////////////////////////////////////////////////////
	mmMath::sPoint3D TransformPointFast(mmMath::sPoint3D* p_psPoint,
																			mmMath::s3DTransformation* p_psTransformation);

	////////////////////////////////////////////////////////////////////////////////
	/// Function calculates point after inverse transformation.
	///
	/// @param[in] p_psPoint pointer to point
	/// @param[in] p_psTransformation pointer to transformation matrix
	/// @return calculated point
	////////////////////////////////////////////////////////////////////////////////
	mmMath::sPoint3D UntransformPoint(mmMath::sPoint3D* p_psPoint,
																		mmMath::s3DTransformation* p_psTransformation);

	////////////////////////////////////////////////////////////////////////////////
	/// Function calculates vector after rotations from transformation.
	///
	/// @param[in] p_psVector pointer to vector
	/// @param[in] p_psTransformation pointer to transformation matrix
	/// @return calculated vector
	////////////////////////////////////////////////////////////////////////////////
	mmMath::sPoint3D TransformVector(mmMath::sPoint3D* p_psVector,
																	 mmMath::s3DTransformation* p_psTransformation);

	////////////////////////////////////////////////////////////////////////////////
	/// Function calculates vector after inverse rotations from transformation.
	///
	/// @param[in] p_psVector pointer to vector
	/// @param[in] p_psTransformation pointer to transformation matrix
	/// @return calculated vector
	////////////////////////////////////////////////////////////////////////////////
	mmMath::sPoint3D UntransformVector(mmMath::sPoint3D* p_psVector,
																		 mmMath::s3DTransformation* p_psTransformation);

	////////////////////////////////////////////////////////////////////////////////
	/// Function transforms vector from local to global coords according to
	/// defined axes of global coordinate set.
	///
	/// @param[in] p_sGlobalXAxis vector with X axis of global coord set
	/// @param[in] p_sGlobalYAxis vector with Y axis of global coord set
	/// @param[in] p_sGlobalZAxis vector with Z axis of global coord set
	/// @param[in] p_sLocalVector vector in local coords to transform
	/// @return calculated vector in global coords
	////////////////////////////////////////////////////////////////////////////////
	mmMath::sPoint3D CalcVectorInGlobalCoords(mmMath::sPoint3D p_sGlobalXAxis,
																						mmMath::sPoint3D p_sGlobalYAxis,
																						mmMath::sPoint3D p_sGlobalZAxis,
																						mmMath::sPoint3D p_sLocalVector);

	////////////////////////////////////////////////////////////////////////////////
	/// Function transforms vector from global to local coords according to
	/// defined axes of global coordinate set.
	///
	/// @param[in] p_sGlobalXAxis vector with X axis of global coord set
	/// @param[in] p_sGlobalYAxis vector with Y axis of global coord set
	/// @param[in] p_sGlobalZAxis vector with Z axis of global coord set
	/// @param[in] p_sGlobalVector vector in global coords to transform
	/// @return calculated vector in local coords
	////////////////////////////////////////////////////////////////////////////////
	mmMath::sPoint3D CalcVectorInLocalCoords(mmMath::sPoint3D p_sGlobalXAxis,
																					 mmMath::sPoint3D p_sGlobalYAxis,
																					 mmMath::sPoint3D p_sGlobalZAxis,
																					 mmMath::sPoint3D p_sGlobalVector);

	////////////////////////////////////////////////////////////////////////////////
	/// Function calculates error from p_vStablePoints to p_vToFitPoints
	/// using min RMS criterion.
	///
	/// @param[in] p_pvStablePoints pointer to set of stable points
	/// @param[in] p_pvToFitPoints pointer to set of points to transform
	/// @param[in] p_psTransformation pointer to transformation matrix
	/// @return calculated error
	////////////////////////////////////////////////////////////////////////////////
	mmReal CalcPointsToPointsMinRMSError(std::vector<sPoint3D>* p_pvStablePoints,
																			 std::vector<sPoint3D>* p_pvToFitPoints,
																			 mmMath::s3DTransformation* p_psTransformation);

	////////////////////////////////////////////////////////////////////////////////
	/// Function calculates best translation (with minimal RMS error) between
	/// groups of points with threshold distance.
	///
	/// @param[in] p_pvStablePoints pointer to set of stable points
	/// @param[in] p_pvToFitPoints pointer to set of points to transform
	/// @param[in] p_psTransformation pointer to transformation matrix
	/// @param[in] p_rIterationDist transformation distance threshold
	/// @return calculated error
	////////////////////////////////////////////////////////////////////////////////
	mmReal CalcPointsToPointsBestTranslation(std::vector<sPoint3D>* p_pvStablePoints,
																					 std::vector<sPoint3D>* p_pvToFitPoints,
																					 mmMath::s3DTransformation* p_psTransformation,
																					 mmReal p_rIterationDist);

	////////////////////////////////////////////////////////////////////////////////
	/// Function calculates translation between first points in vectors after
	/// transformation.
	///
	/// @param[in] p_pvStablePoints pointer to set of stable points
	/// @param[in] p_pvToFitPoints pointer to set of points to transform
	/// @param[in] p_psTransformation pointer to transformation matrix
	/// @return calculated error
	////////////////////////////////////////////////////////////////////////////////
	mmReal CalcFirstPointsTranslation(std::vector<sPoint3D>* p_pvStablePoints,
																		std::vector<sPoint3D>* p_pvToFitPoints,
																		mmMath::s3DTransformation* p_psTransformation);

	////////////////////////////////////////////////////////////////////////////////
	/// Function calculates simple transformation from p_vStablePoints to p_vToFitPoints
	/// using first three poits angles criterion.
	///
	/// @param[in] p_vStablePoints set of stable points
	/// @param[in] p_vToFitPoints set of points to transform
	/// @param[in] p_rIterValue iteration value in [mm]
	/// @param[out] p_prFittingError if not NULL then fttng RMS error is returned
	/// @return calculated transformation
	////////////////////////////////////////////////////////////////////////////////
	mmMath::s3DTransformation CalcInitialPointsToPointsTransformation(std::vector<sPoint3D> p_vStablePoints,
																																		std::vector<sPoint3D> p_vToFitPoints,
																																		mmReal p_rIterValue = 1.0,
																																		mmReal* p_prFittingError = NULL);

	////////////////////////////////////////////////////////////////////////////////
	/// Function calculates transformation from p_vStablePoints to p_vToFitPoints
	/// using min RMS criterion.
	///
	/// @param[in] p_vStablePoints set of stable points
	/// @param[in] p_vToFitPoints set of points to transform
	/// @param[in] p_rMaxIterValue maximum iteration value in [mm]
	/// @param[in] p_rMinIterValue minimum iteration value in [mm]
	/// @param[in] p_bLockTranslations if equal to TRUE then translationa are locked
	/// @param[in] p_psInitialTransformation initial transformation for iterations
	/// @param[out] p_prFittingError if not NULL then fttng RMS error is returned
	/// @return calculated transformation
	////////////////////////////////////////////////////////////////////////////////
	mmMath::s3DTransformation CalcPointsToPointsTransformation(std::vector<sPoint3D> p_vStablePoints,
																														 std::vector<sPoint3D> p_vToFitPoints,
																														 mmReal p_rMaxIterValue = 5.0,
																														 mmReal p_rMinIterValue = 0.000001,
																														 bool p_bLockTranslations = false,
																														 mmMath::s3DTransformation* p_psInitialTransformation = NULL,
																														 mmReal* p_prFittingError = NULL);

	////////////////////////////////////////////////////////////////////////////////
	/// Function calculates transformation from p_vStablePoints to p_vToFitPoints
	/// with assumption that points representing a rigid body. It uses min RMS
	/// criterion.
	///
	/// @param[in] p_vStablePoints set of stable points
	/// @param[in] p_vToFitPoints set of points to transform
	/// @param[in] p_rMaxIterValue maximum iteration value in [mm]
	/// @param[in] p_rMinIterValue minimum iteration value in [mm]
	/// @param[in] p_psInitialTransformation initial transformation for iterations
	/// @param[out] p_prFittingError if not NULL then fttng RMS error is returned
	/// @return calculated transformation
	////////////////////////////////////////////////////////////////////////////////
	mmMath::s3DTransformation CalcRigidBodyTransformation(std::vector<sPoint3D> p_vStablePoints,
																												std::vector<sPoint3D> p_vToFitPoints,
																												mmReal p_rMaxIterValue = 5.0,
																												mmReal p_rMinIterValue = 0.000001,
																												mmMath::s3DTransformation* p_psInitialTransformation = NULL,
																												mmReal* p_prFittingError = NULL);

	////////////////////////////////////////////////////////////////////////////////
	/// Function calculates transformation from p_sStableVector to p_sToFitVector
	/// with assumption that only rotations are used.
	///
	/// @param[in] p_sStableVector stable vector
	/// @param[in] p_sToFitVector to transform vector
	/// @param[in] p_bLockXRotation defines if X rotation is used
	/// @param[in] p_bLockYRotation defines if Y rotation is used
	/// @param[in] p_bLockZRotation defines if Z rotation is used
	/// @param[in] p_rMaxIterValueInDeg maximum iteration value in [deg]
	/// @param[in] p_rMinIterValueInDeg minimum iteration value in [deg]
	/// @param[out] p_prFittingError if not NULL then error is returned
	/// @return calculated transformation
	////////////////////////////////////////////////////////////////////////////////
	mmMath::s3DTransformation CalcVectorToVectorTransformation(mmMath::sPoint3D p_sStableVector,
																														 mmMath::sPoint3D p_sToFitVector,
																														 bool p_bLockXRotation = false,
																														 bool p_bLockYRotation = false,
																														 bool p_bLockZRotation = false,
																														 mmReal p_rMaxIterValueInDeg = 5.0,
																														 mmReal p_rMinIterValueInDeg = 0.0000001,
																														 mmReal* p_prFittingError = NULL);

	////////////////////////////////////////////////////////////////////////////////
	/// Function calculates plane and line intersection in 3D.
	///
	/// @param[in] p_sPlane plane formula
	/// @param[in] p_sLine line formula
	/// @return calculated point
	////////////////////////////////////////////////////////////////////////////////
	mmMath::sPoint3D CalcPlaneAndLineIntersection3D(mmMath::sPlane3D p_sPlane,
																									mmMath::sLine3D p_sLine);

	////////////////////////////////////////////////////////////////////////////////
	/// Function calculates 3 order polynomial X to Y.
	///
	/// @param[in] p_sInValues plane formula
	/// @return definition of polynomial
	////////////////////////////////////////////////////////////////////////////////
	mmMath::s3OrderPolynomialXtoY Calc3OrderPolynomialYtoY(mmMath::s3OrderPolynomialXtoYCalc p_sInValues);

	////////////////////////////////////////////////////////////////////////////////
	/// Function calculates if 2D point is located inside rectangle 2D.
	///
	/// @param[in] p_sPoint11 point 1 coordinates
	/// @param[in] p_sPoint12 point 2 coordinates
	/// @param[in] p_sPoint21 point 3 coordinates
	/// @param[in] p_sPoint22 point 4 coordinates
	/// @param[in] p_sPoint coordinates of calculated point
	/// @return TRUE if it is inside, FALSE otherwise
	////////////////////////////////////////////////////////////////////////////////
	bool IsPointInsideRectangle2D(mmMath::sPoint2D p_sPoint11,
																mmMath::sPoint2D p_sPoint12,
																mmMath::sPoint2D p_sPoint21,
																mmMath::sPoint2D p_sPoint22,
																mmMath::sPoint2D p_sPoint);

	////////////////////////////////////////////////////////////////////////////////
	/// Function calculates linear weights of pont inside rectangle.
	///
	/// @param[in] p_sPoint11 point 1 coordinates
	/// @param[in] p_sPoint12 point 2 coordinates
	/// @param[in] p_sPoint21 point 3 coordinates
	/// @param[in] p_sPoint22 point 4 coordinates
	/// @param[in] p_sPoint coordinates of calculated point
	/// @param[out] p_prWeightX pointer to resulting X coords weight
	/// @param[out] p_prWeightY pointer to resulting Y coords weight
	////////////////////////////////////////////////////////////////////////////////
	void CalcXYWeightsFromRectangle2D(mmMath::sPoint2D p_sPoint11,
																		mmMath::sPoint2D p_sPoint12,
																		mmMath::sPoint2D p_sPoint21,
																		mmMath::sPoint2D p_sPoint22,
																		mmMath::sPoint2D p_sPoint,
																		mmReal* p_prWeightX,
																		mmReal* p_prWeightY);

	////////////////////////////////////////////////////////////////////////////////
	/// Function searches for largest group of points in two sets. Criterion of
	/// selection is based on rule that all distances between ponts insode group
	/// should be the same for both sets with accuracy less than p_rDistanceThreshold.
	///
	/// @param[in] p_pv1stGroupOfPoints pointer to vector with 1st group
	/// @param[in] p_pv2ndGroupOfPoints pointer to vector with 2nd group
	/// @param[in] p_rDistanceThreshold distance threshold
	/// @param[out] p_pvFoundPointIndexes pointer to vector which stores indexes
	///					 		of largest group points
	/// @return number of points in largest group
	////////////////////////////////////////////////////////////////////////////////
	mmInt FindLargerGroupOfFittingPointsFromOrderedGroups(std::vector<mmMath::sPoint3D>* p_pv1stGroupOfPoints,
																												std::vector<mmMath::sPoint3D>* p_pv2ndGroupOfPoints,
																												mmReal p_rDistanceThreshold,
																												std::vector<mmInt>* p_pvFoundPointIndexes);

	////////////////////////////////////////////////////////////////////////////////
	/// Function calculates angle between two 3D vectors.
	///
	/// @param[in] p_psP3D1 pointer to normalized vector 1
	/// @param[in] p_psP3D2 pointer to normalized vector 2
	/// @return angle in degrees between vectors
	////////////////////////////////////////////////////////////////////////////////
	mmReal CalcNormalizedVector3DToNormalizedVector3DAngle(mmMath::sPoint3D* p_psP3D1,
																												 mmMath::sPoint3D* p_psP3D2);
};

#endif
